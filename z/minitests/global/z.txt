1. data can be literal,list,object,path

2. type, _id, _ref, _source can be string or list of string

3. cond ist always object
	key: eval function,
	value: data

4. RHS path .[prop.]*prop refers to serverData object

5. LHS path prop[.prop]* refers to rsg object (=node)

6. node 
	- has meta (ignored for now)
	- has a type (default:panel), 
	- can be named (spec nodes)
	- has a parent (node)
	- has children (nodes) =>koennen multiple types of children sein, but for now it is just panels for panel und elm for list
	- has a relative address within parent
	- may have absolute address (just a of path from ROOT)
	- has a component: pool referring to all oids for which this node is instantiated
		(static object pool=null or undefined)
		pool inherited from parent or set
	- has a data component
	- may have params: all visual directives as needed/processable per type
	- may have other key/values as type (panels, elm, dict, ...)

7. address can be 
	key (if parent is object) or 
	index (if parent is list)

8. oid is serverData object ID

9. type
	can be standard type (panel, list, info for now)
	or node name (named spec node)

_________________
process:

//during tree building process, will keep a list of nodes
//for each node in SPEC (bl[spName]), generations of nodes produced in each
//pass, the last of which is the starting point for next
//generation

//at the end of this process, bl.ROOT will hold complete rsg presentation and
//can then be presented

orthogonal processes:
- stages: each node evolves to new node
- 

example of final node:
	//welches object will ich eigentlich?
	let nRes1 ={
		type: ['info'], //copy of type as list
		data: 'hallo', //copy of data
		
		cond: null, //object
		_source: null, //rsg node to pull pool filtered by source from
		// may change! therefore this should be a string
		_id: [],
		_ref: [],

		area:'table1', //name of domel
		host: mBy('table1'), //domel
		parent: null, //because ROOT of tree,
		//or node that has host as ui

		spName:'ROOT', //find self in sp.ROOT
		pool:[], //no associated serverData
		oid: null, //server object associated to this instance
		//data could be path within that object!

		ui:null,//to be created by type class
		params:{bg:'blue',fg:'white'}, //defaults set for each type class
		// visual props either from node or defaults

		uid: getUID(), //unique id where node can be found in all nodes dict held by rsg
	};

=>koennte schon in preprocessing 
=>new and removed nodes kennzeichnen!
achtung! removed allein ist nicht genug!
es kann ja auch eine hand changen!
es kann auch eine property removed werden!
=>auch mod nodes kann ich presenten!

=>erkenne new object daran dass es keine RSG component hat
=>woran erkenne ich removed object?or property???

frage: kann ein einziger node mehrere props darstellen?
wenn ich es so mache dass per node and prop 1 node ist dann nicht!
dann bekomme aber ca 20K objects

max:200K key-value pairs easily!
100x10x10=10K-100K kann es schon werden



















































_id

_ref

cond
- eval against data =>attach a _pool property,to each object attach a _rsg property

_source
- _source: all_cards => use condNode[all_cards].pool

prototype

meta

spec node evolution:
1. orig node
2. default type added, _id > places ==> nProto

 

















